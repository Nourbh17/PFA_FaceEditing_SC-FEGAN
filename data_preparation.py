# -*- coding: utf-8 -*-
"""Data_preparation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pF2WiMksPvRM5ugg9fSxnBBjIEPmTyKJ
"""

from google.colab import drive
drive.mount('/content/drive/')

!pip install mtcnn

!pip install tensorflow-io
# print('installed succ cd next')

# Commented out IPython magic to ensure Python compatibility.
# %cd "/content/drive/MyDrive/PFA/"
print('cd done classes next')

import numpy as np
import cv2 as cv
from face_toolbox_keras_master.models.parser.BiSeNet.bisenet import BiSeNet_keras

FILE_PATH = "/content/drive/MyDrive/PFA/face_toolbox_keras_master/models/parser"


class FaceParser():
    def __init__(self, path_bisenet_weights=FILE_PATH + "/BiSeNet/BiSeNet_keras.h5", detector=None):
        self.parser_net = None
        self.detector = detector
        self.build_parser_net(path_bisenet_weights)

    def build_parser_net(self, path):
        parser_net = BiSeNet_keras()
        parser_net.load_weights(path)
        self.parser_net = parser_net

    def set_detector(self, detector):
        self.detector = detector

    def remove_detector(self):
        self.detector = None

    def parse_face(self, im, bounding_box=None, with_detection=False):
        orig_h, orig_w = im.shape[:2]

        # Detect/Crop face RoI
        if bounding_box == None:

            faces = [im]
        else:
            x0, y0, x1, y1 = bounding_box
            x0, y0 = np.maximum(x0, 0), np.maximum(y0, 0)
            x1, y1 = np.minimum(x1, orig_h), np.minimum(y1, orig_w)
            x0, y0, x1, y1 = map(np.int32, [x0, y0, x1, y1])
            faces = [im[x0:x1, y0:y1, :]]

        maps = []
        for face in faces:
            # Preprocess input face for parser networks
            orig_h, orig_w = face.shape[:2]
            inp = cv.resize(face, (512, 512))
            inp = self.normalize_input(inp)
            inp = inp[None, ...]

            # Parser networks forward pass
            # Do NOT use bilinear interp. which adds artifacts to the parsing map
            out = self.parser_net.predict([inp])[0]
            parsing_map = out.argmax(axis=-1)
            parsing_map = cv.resize(
                parsing_map.astype(np.uint8),
                (orig_w, orig_h),
                interpolation=cv.INTER_NEAREST)
            maps.append(parsing_map)
        return maps

    @staticmethod
    def normalize_input(x, mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)):
        # x should be RGB with range [0, 255]
        return ((x / 255) - mean) / std

import math
import cv2 as cv
import os
import numpy as np
import tensorflow as tf
from mtcnn.mtcnn import MTCNN

import tensorflow_io as tfio

detector = MTCNN()


class load_data:
    def __init__(self, path_image):
        self.image = path_image


    def hair_mask(self,pic):
        parser = FaceParser()
        img = pic[..., ::-1]
        parsed = parser.parse_face(img, with_detection=False)
        component_mask = np.zeros(tuple(img.shape[:-1]))
        component_mask[parsed[0] == 17] = 1
        component_mask = np.reshape(component_mask, (img.shape[0], img.shape[1], 1))
        return component_mask.astype("float32")

    def get_color(self,pic):
        annotation_colors = [
            '0, background', '1, skin', '2, left eyebrow', '3, right eyebrow',
            '4, left eye', '5, right eye', '6, glasses', '7, left ear', '8, right ear', '9, earings',
            '10, nose', '11, mouth', '12, upper lip', '13, lower lip',
            '14, neck', '15, neck_l', '16, cloth', '17, hair', '18, hat']

        parser = FaceParser()
        img = pic[..., ::-1]
        parsed = parser.parse_face(img, with_detection=False)

        # blurring image
        img = cv.cvtColor(img, cv.COLOR_BGR2RGB)
        imgg = cv.medianBlur(img, 5)
        bilateral = imgg
        for i in range(20):
            bilateral = cv.bilateralFilter(bilateral, 20, 30, 30)
        median_image = np.zeros(bilateral.shape)
        for i in range(len(annotation_colors)):
            component_mask = np.zeros(tuple(pic.shape[:-1]))
            component_mask[parsed[0] == i] = 1
            masked = np.multiply(cv.cvtColor(
                bilateral, cv.COLOR_RGB2BGR), np.expand_dims(component_mask, axis=-1))
            median_image += masked
        median_image = median_image.astype(np.uint8)
        median_image = cv.cvtColor(median_image, cv.COLOR_BGR2RGB)
        return median_image

    def edges_detection(self,pic):
        (H, W) = pic.shape[:2]
        blob = cv.dnn.blobFromImage(pic, scalefactor=1.0, size=(W, H),
                                    swapRB=False, crop=False)
        file= "deploy.prototxt"
        caf = "hed_pretrained_bsds.caffemodel"

        net = cv.dnn.readNetFromCaffe(file, caf)
        net.setInput(blob)
        hed = net.forward()
        hed = cv.resize(hed[0, 0], (pic.shape[0], pic.shape[1]))
        hed = (255 * hed).astype("uint8")
        ret2, th2 = cv.threshold(hed, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU)
        binary_mask = np.reshape(th2, (pic.shape[0], pic.shape[1], 1))
        return binary_mask.astype(np.uint8)

    def create_mask(self, pic, number_of_mask=3):
        panel_mask = np.zeros((pic.shape[0], pic.shape[1], 1), dtype="float32")
        faces = detector.detect_faces(pic)
        if len(faces) == 0:
            # Handle the case where no faces are detected
            print("No faces detected")
            return None
        x1, y1, width, height = faces[0]["box"]
        x2, y2 = x1 + width, y1 + height
        binary_mask = np.zeros((y2 - y1, x2 - x1, 1), dtype="int32")

        for i in range(number_of_mask):
            start_x = np.random.randint(0, x2 - x1)
            start_y = np.random.randint(0, y2 - y1)
            start_angle = np.random.randint(180)
            numV = np.random.randint(80, 100)
            for j in range(numV):
                angleP = np.random.randint(-15, 15)
                if j % 2 == 0:
                    angle = start_angle + angleP
                else:
                    angle = start_angle + angleP + 180
                length = np.random.randint(80, 100)
                end_x = start_x + int(length * math.cos(math.radians(angle)))
                end_y = start_y + int(length * math.sin(math.radians(angle)))

                cv.line(binary_mask, (start_x, start_y), (end_x, end_y), 255, 15)
                start_x = end_x
                start_y = end_y

        panel_mask[y1:y2, x1:x2] = binary_mask[:, :]
        hair_mask_num = np.random.randint(2, 8)
        if hair_mask_num > 5:
            hair_mask = self.hair_mask(pic)
            panel_mask += hair_mask
        panel_mask = np.where(np.clip(panel_mask, 0., 255.) == 0, 0., 255.)/255.
        return panel_mask.astype("uint8")

    def get_data(self ):
        pic = cv.imread(self.image)
        pic = cv.resize(pic, (512, 512))
        pic = cv.cvtColor(pic, cv.COLOR_BGR2RGB)
        binary_mask = self.create_mask(pic)
        sketch = self.edges_detection(pic)
        color = self.get_color(pic)
        noise = np.random.normal(size=(pic.shape[0], pic.shape[1], 1))
        reversed_mask = 1 - binary_mask
        input_image = pic * reversed_mask
        sketch = sketch * binary_mask
        color = color * binary_mask
        noise = noise * binary_mask
        return pic, input_image, sketch, color, binary_mask * 255, noise

class Data_Preparation:
    def __init__(self, folder_path):
        self.path = folder_path
        self.label, self.total_images, self.total_sketch, self.total_color, self.total_mask, self.total_noise = \
            self.data_load()
        self.ground_truth, self.total_input = self.data_batch()
        self.incomplete_image = self.total_input[:][..., 0:3]
        self.sketch = self.total_input[:][..., 3:4]
        self.color = self.total_input[:][..., 4:7]
        self.mask = self.total_input[:][..., 7:8]
        self.noise = self.total_input[:][..., 8:9]
        self.batch_data = [self.incomplete_image, self.sketch, self.color, self.mask, self.noise]

    def get_file_paths(self,base_path, subdir):
        full_path = os.path.join(base_path, subdir)
        return [os.path.join(full_path, name) for name in os.listdir(base_path) if os.path.isfile(os.path.join(full_path, name))]

    def data_load(self):
        data_paths = [os.path.join(self.path, name) for name in os.listdir(self.path) if os.path.isfile(os.path.join(self.path, name))]
        edges = get_file_paths(self.path,"sketch")
        images = get_file_paths(self.path,"input")
        masks = get_file_paths(self.path,"mask")
        true_img = get_file_paths(self.path,"truth")
        noises = get_file_paths(self.path,"noise")
        colors = get_file_paths(self.path,"color")

        return true_img, images, edges, colors, masks, noises



    # def data_load(self, ):
    #     true_sketch = []
    #     true_img = []
    #     images = []
    #     colors = []
    #     edges = []
    #     masks = []
    #     noises = []

    #     data_folder = [name for name in os.listdir(self.path)]

    #     images_color = [img for img in os.listdir(self.path + "/" + data_folder[0])]

    #     truth = [img for img in os.listdir(self.path + "/" + data_folder[5])]

    #     images_input = [img for img in os.listdir(self.path + "/" + data_folder[1])]

    #     images_mask = [img for img in os.listdir(self.path + "/" + data_folder[2])]

    #     images_noise = [img for img in os.listdir(self.path + "/" + data_folder[3])]

    #     images_sketch = [img for img in os.listdir(self.path + "/" + data_folder[4])]

    #     for i in range(len(images_color)):
    #         actual_path,path, sketch_path, color_path, mask_path, noise_path = truth[i],\
    #                                                                             images_input[i], \
    #                                                                             images_sketch[i], \
    #                                                                             images_color[i], \
    #                                                                             images_mask[i], \
    #                                                                             images_noise[i]

    #         true_img.append(self.path + data_folder[1] + "/" + actual_path)
    #         images.append(self.path + data_folder[2] + "/" + path)
    #         edges.append(self.path + data_folder[5] + "/" + sketch_path)
    #         colors.append(self.path + data_folder[0] + "/" + color_path)
    #         masks.append(self.path + data_folder[3] + "/" + mask_path)
    #         noises.append(self.path + data_folder[4] + "/" + noise_path)

    #     return true_img, images, edges, colors, masks, noises

    def data_batch(self, ):
        total_label = []
        total_batch = []
        for i in range(len(self.total_sketch)):
            actual = tf.image.decode_jpeg(tf.io.read_file(self.label[i]), channels=3)
            actual = tfio.experimental.color.bgr_to_rgb(actual)
            actual = (tf.cast(actual, dtype=tf.float32) / 127.5) - 1.0

            pic = tf.image.decode_jpeg(tf.io.read_file(self.total_images[i]), channels=3)
            pic = tfio.experimental.color.bgr_to_rgb(pic)
            pic = (tf.cast(pic, dtype=tf.float32) / 127.5 )- 1.0

            sketch = tf.image.decode_jpeg(tf.io.read_file(self.total_sketch[i]), channels=1)
            sketch = tf.where(sketch > 150,255.,0.)
            sketch = tf.cast(sketch, dtype=tf.float32) / 255.

            color = tf.image.decode_jpeg(tf.io.read_file(self.total_color[i]), channels=3)
            color = tfio.experimental.color.bgr_to_rgb(color)
            color = (tf.cast(color, dtype=tf.float32) / 127.5 )- 1.0

            mask = tf.image.decode_jpeg(tf.io.read_file(self.total_mask[i]), channels=1)
            mask = tf.where(mask > 150,255.,0.)
            mask = tf.cast(mask, dtype=tf.float32) / 255.

            noise = tf.image.decode_jpeg(tf.io.read_file(self.total_noise[i]), channels=1)
            noise = tf.cast(noise, dtype=tf.float32) / 255.

            batch_input = tf.concat([pic, sketch, color, mask, noise], axis=-1)
            total_batch.append(batch_input)
            total_label.append(actual)

        total_batch = tf.stack(total_batch, axis=0)
        total_label = tf.stack(total_label, axis=0)
        return total_label, total_batch

from PIL import Image
import os

# def get_file_paths(base_path, subdir):
#     full_path = os.path.join(base_path, subdir)
#     return [os.path.join(full_path, name) for name in os.listdir(path) if os.path.isfile(os.path.join(full_path, name))]
def get_file_paths(base_path, subdir):
    full_path = os.path.join(base_path, subdir)
    return [os.path.join(full_path, name) for name in os.listdir(base_path) if os.path.isfile(os.path.join(base_path, name))]

def remove_image(image_path):
    try:
        os.remove(image_path)
        print(f"Image at {image_path} has been removed successfully.")
    except OSError as e:
        print(f"Error: {e.filename} - {e.strerror}")

from PIL import Image

def normalize_image(image):
    image = (image - np.min(image)) / (np.max(image) - np.min(image))  # Normalize to [0, 1]
    image = (image * 255).astype(np.uint8)  # Scale to [0, 255] and convert to uint8
    return image

def save_image(img, path, mode='JPEG',normalize = False):
    array = np.array(img, dtype=np.float32 if normalize else np.uint8)
    # print(f"Processing image {idx}: shape = {array.shape}, dtype = {array.dtype}")
    if normalize:
        array = normalize_image(array)
    try:
        if mode == 'L':
            np_img = np.squeeze(array, axis=2)  # axis=2 is channel dimension
            im= Image.fromarray(np_img)
            # im = Image.fromarray(y.astype(np.uint8)).convert(mode)
        else:
            im = Image.fromarray(array.astype(np.uint8))
        im.save(path,mode=mode)
        # print(f"Saved {path}")
    except Exception as e:
       print(f"Error processing image : {e}")

def data_div(path):

    data_paths = [os.path.join(path, name) for name in os.listdir(path) if os.path.isfile(os.path.join(path, name))]
    print(len(data_paths))
    sketch_path = get_file_paths(path,"sketch")
    input_path = get_file_paths(path,"input")
    mask_path = get_file_paths(path,"mask")
    truth_path = get_file_paths(path,"truth")
    noise_path = get_file_paths(path,"noise")
    color_path = get_file_paths(path,"color")

    for i,img in  enumerate(data_paths) :
        try :
            l = load_data(img)
            truth, input_image, sketch, color, mask, noise = l.get_data()
            if mask is None :
                print( "removed   ", img)
                os.remove(img)
                continue
            save_image(input_image, input_path[i])  # RGB images
            save_image(truth, truth_path[i])  # RGB images
            save_image(mask, mask_path[i], mode='L')  # Grayscale images
            save_image(noise, noise_path[i],mode='L', normalize=True)  # RGB or Grayscale images
            save_image(color, color_path[i])  # RGB images
            save_image(sketch, sketch_path[i], mode='L')  # Grayscale images
            print("image  done ",i,img)
            try :
              remove_image(img)
            except Exception as e :
                print("can't remove img : ", img)
                continue

        except Exception as e:
            print(f"Error image  {i}: {img}")
            remove_image(img)
            continue

    # return data_paths, truth, images_input, images_sketch, images_color, images_mask, images_noise

path ="celebahq/CelebAMask-HQ/CelebA-HQ-img"
data_div(path)

